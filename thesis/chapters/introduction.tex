%!TEX root = ../dissertation.tex

\chapter{Introduction}
\label{chapter:introduction}

The publish-subscribe (pub-sub) interaction paradigm is an approach that has
received an increasing amount of attention over the course of the century
\cite{Kermarrec2013} \cite{Eugster2003}.  This is mainly due to its special
properties, that allow for full decoupling of all the communicating parties.
Taking a closer look at this definition one can see that this comes hand in
hand with the way information is consumed nowadays, with the exponential growth
of social networks like Twitter and the usage of feeds such as RSS.

\section{Motivation}
First, we should define what the publish-subscribe pattern is.  In this
interaction paradigm, subscribers (or consumers) sign up for events, or classes
of events, from publishers (or producers) that are subsequently asynchronously
delivered. This decoupling can be broken into three different parts. The
decoupling in time, space and synchronisation.

The time decoupling comes from the fact that publishers and subscribers do not
need to be actively interacting with each other at the same time; this means
that the publisher can publish some events while the subscriber is disconnected
and the subscriber can be notified of an event whose publisher is disconnected.
Space decoupling gives both parties the benefit of not needing to know each
other in order to communicate, given that consumers and producers are focused
on their specific roles (consuming/producing) and do not care for who is doing
what, or how many producers are there, for example. Synchronization decoupling is a
consequence of the asynchronous nature of the pub-sub pattern, as publishers do
not need to be blocked while producing events and subscribers can be
asynchronously notified.  The decoupling that this kind of system offers makes
it the ideal candidate for very large networks that need a way to communicate
in an efficient way.

Due to the properties described above, a lot of applications rely on the
publish-subscribe paradigm and a lot of work has been done by companies like
Twitter~\footnote{\url{https://www.infoq.com/presentations/Twitter-Timeline-Scalability}},
Spotify~\cite{Setty2013} and LinkedIn into making these systems capable of
scaling to a large number of participants, with the creation of tools like
Kafka~\footnote{\url{http://kafka.apache.org/documentation/\#design}}, which
aim at guaranteeing low latency and high event throughput. Other examples are
the multiple message queue systems like Apache Active
MQ~\footnote{\url{http://activemq.apache.org}},
RabbitMQ~\footnote{\url{https://www.rabbitmq.com/}},
Redis~\footnote{\url{https://redis.io/topics/pubsub}}, etc. Most of these
solutions are, of course, centralised and as such suffer from all the common
issues that affect centralised solutions: it is quite hard to maintain and
scale these systems to a large number of clients. \acrfull{p2p} networks, on
the other hand, have proven numerous times, that this is where they shine, with
examples such as Gnutella, Skype and most recently
\acrshort{ipfs}~\footnote{\url{https://ipfs.io/}}. Or through hybrid solutions
such as the one employed at Spotify to manage social
interactions~\cite{Setty2013}. All of these systems are a living proof of the
high scalability \acrshort{p2p} can offer, with pub-sub systems over
\acrshort{p2p} networks being an active research topic with a lot of attention.

\section{Contributions}

As we are going to cover in the next sections, lots of different solutions
exist. However, most of them either rely on a centralised or hierarchic network
to have a reliable system, with stronger delivery and persistence guarantees,
or end up sacrificing these same properties in order to have a decentralised
system with the potential to scale to a much larger network. There is also, to
the best of our knowledge, a lack of pub-sub systems with a strong focus on
persistence.

We intend to address this in Pulsarcast by focusing in the following
properties:

\begin{itemize}
  \item
    Strong focus on reliability;
  \item
    Eventual delivery guarantees;
  \item
    Data persistence;
  \item
    Ability to scale to a vast number of users;
  \item
    Takes advantage of the network infrastructure and network protocols we have in place today;
\end{itemize}

Besides the specification and architectural model of our system we also provide
a concrete implementation of it. So, in order to validate the solution we
purpose we have created the following:

\begin{itemize}
  \item
    A Javascript implementation module of Pulsarcast with a clearly defined \acrshort{api} through which applications can integrate with;
  \item
    A distributed test runner capable of running large scale test scenarios and simulate abnormal network conditions;
  \item
    An easy to automate test-suite based on a real world application;
\end{itemize}

\section{Document Roadmap}

This document is structured as follows: Chapter \ref{chapter:related-work}
presents and analyses our related work. Chapter \ref{chapter:pulsarcast}
introduces and describes Pulsarcast, its architecture, data structures and
algorithms. Chapter \ref{chapter:implementation} covers the implementation of
our solution, with code snippets and \acrshort{uml} class diagrams. Next,
chapter \ref{chapter:evaluation} explains our evaluation methodology and
presents those results. Finally, chapter \ref{chapter:conclusion} provides a
set of closing remarks and a set of improvements and future work.

