%!TEX root = ../dissertation.tex

\chapter{Introduction}
\label{chapter:introduction}

The publish-subscribe (pub-sub) interaction paradigm is an approach that has
received an increasing amount of attention over the course of the century
\cite{Kermarrec2013} \cite{Eugster2003}.  This is mainly due to its special
properties, that allow for full decoupling of all the communicating parties.
Taking a closer look at this definition one can see that this comes hand in
hand with the way information is consumed nowadays, with the exponential growth
of social networks like Twitter and the usage of feeds such as RSS.


\section{Motivation}
First, we should define what the publish-subscribe pattern is.  In this
interaction paradigm, subscribers (or consumers) sign up for events, or classes
of events, from publishers (or producers) that are subsequently asynchronously
delivered. This decoupling can be broken into three different parts. The
decoupling in time, space and synchronisation.

The time decoupling comes from the fact that publishers and subscribers do not
need to be actively interacting with each other at the same time; this means
that the publisher can publish some events while the subscriber is disconnected
and the subscriber can be notified of an event whose publisher is disconnected.
Space decoupling gives both parties the benefit of not needing to know each
other in order to communicate, given that consumers and producers are focused
on their specific roles (consuming/producing) and do not care for who is doing
what, or how many producers are for example. Synchronization decoupling is a
consequence of the asynchronous nature of the pub-sub pattern, as publishers do
not need to be blocked while producing events and subscribers can be
asynchronously notified.  The decoupling that this kind of system offers makes
it the ideal candidate for very large networks that need a way to communicate
in an efficient way.

Due to the properties described above, a lot of applications rely on the
publish-subscribe paradigm and a lot of work has been done by companies like
Twitter~\footnote{https://www.infoq.com/presentations/Twitter-Timeline-Scalability}
and LinkedIn into making these systems capable of scaling to a large number of
participants, with the creation of tools like
Kafka~\footnote{http://kafka.apache.org/documentation/\#design}, which aim at
guaranteeing low latency and high event throughput. Other examples are the
multiple message queue systems like Apache Active
MQ~\footnote{http://activemq.apache.org/},
RabbitMQ~\footnote{https://www.rabbitmq.com/},
Redis~\footnote{https://redis.io/topics/pubsub}, etc.  These solutions are, of
course, centralised and as such suffer from all the common issues that affect
centralised solutions: it is quite hard to maintain and scale these systems to
a large number of clients. \acrfull{p2p} networks, on the other hand, have
proven numerous times, that this is where they shine, with examples such as
Gnutella, Skype and most recently \acrshort{ipfs}~\footnote{https://ipfs.io/}.
All of these systems are a living proof of the high scalability \acrshort{p2p} can offer,
with pub-sub systems over \acrshort{p2p} networks being an active research topic with a
lot of attention.

\section{Goals}

As we are going to cover in the next sections, lots of different
solutions exist. However, most of them either rely on a
centralised or hierarchic network to have a reliable system, with
stronger delivery and persistence guarantees, or end up sacrificing
these same properties in order to have a decentralised system with the
potential to scale to a much larger network.

The solution we propose is Pulsarcast, a pub-sub module with a strong focus on
reliability, eventual delivery guarantees and data persistence, while
maintaining the ability to scale to a vast number of users. Our solution takes
advantage of the network infrastructure and network protocols we have in place
today. There is also, to the best of our knowledge, a lack of pub-sub systems
with such a strong focus on persistence, which is something our solution does.

\section{Document Roadmap}

TODO
