%!TEX root = ../dissertation.tex

\chapter{Introduction}
\label{chapter:introduction}

The publish-subscribe (pub-sub) interaction paradigm is an approach that has
received an increasing amount of attention over the course of the century
\cite{Kermarrec2013} \cite{Eugster2003}.  This is mainly due to its special
properties, that allow for full decoupling of all the communicating parties.
Taking a closer look at this definition one can see that this comes hand in
hand with the way information is consumed nowadays, with the exponential growth
of social networks like Twitter and the usage of feeds such as RSS.


\section{Motivation}
First, we should define what the publish-subscribe pattern is.  In this
interaction paradigm, subscribers (or consumers) sign up for events, or classes
of events, from publishers (or producers) that are subsequently asynchronously
delivered. This decoupling can be broken into three different parts. The
decoupling in time, space and synchronisation.

The time decoupling comes from the fact that publishers and subscribers do not
need to be actively interacting with each other at the same time; this means
that the publisher can publish some events while the subscriber is disconnected
and the subscriber can be notified of an event whose publisher is disconnected.
Space decoupling gives both parties the benefit of not needing to know each
other in order to communicate, given that consumers and producers are focused
on their specific roles (consuming/producing) and do not care for who is doing
what, or how many producers are there, for example. Synchronization decoupling is a
consequence of the asynchronous nature of the pub-sub pattern, as publishers do
not need to be blocked while producing events and subscribers can be
asynchronously notified.  The decoupling that this kind of system offers makes
it the ideal candidate for very large networks that need a way to communicate
in an efficient way.

Due to the properties described above, a lot of applications rely on the
publish-subscribe paradigm and a lot of work has been done by companies like
Twitter~\footnote{\url{https://www.infoq.com/presentations/Twitter-Timeline-Scalability}}
and LinkedIn into making these systems capable of scaling to a large number of
participants, with the creation of tools like
Kafka~\footnote{\url{http://kafka.apache.org/documentation/\#design}}, which
aim at guaranteeing low latency and high event throughput. Other examples are
the multiple message queue systems like Apache Active
MQ~\footnote{\url{http://activemq.apache.org}},
RabbitMQ~\footnote{\url{https://www.rabbitmq.com/}},
Redis~\footnote{\url{https://redis.io/topics/pubsub}}, etc.  These solutions
are, of course, centralised and as such suffer from all the common issues that
affect centralised solutions: it is quite hard to maintain and scale these
systems to a large number of clients. \acrfull{p2p} networks, on the other
hand, have proven numerous times, that this is where they shine, with examples
such as Gnutella, Skype and most recently
\acrshort{ipfs}~\footnote{\url{https://ipfs.io/}}.  All of these systems are a
living proof of the high scalability \acrshort{p2p} can offer, with pub-sub
systems over \acrshort{p2p} networks being an active research topic with a lot
of attention.

\section{Contributions}

As we are going to cover in the next sections, lots of different solutions
exist. However, most of them either rely on a centralised or hierarchic network
to have a reliable system, with stronger delivery and persistence guarantees,
or end up sacrificing these same properties in order to have a decentralised
system with the potential to scale to a much larger network.

Our contribution to address these issues is Pulsarcast, a pub-sub solution with
the following properties:

\begin{itemize}
  \item
    Strong focus on reliability;
  \item
    Eventual delivery guarantees;
  \item
    Data persistence;
  \item
    Ability to scale to a vast number of users;
  \item
    Takes advantage of the network infrastructure and network protocols we have in place today;
\end{itemize}

To validate the solution we purpose we have created a Javascript implementation
module of Pulsarcast, as well as a test-suite and a distributed test runner for
it. There is also, to the best of our knowledge, a lack of pub-sub systems with
such a strong focus on persistence, which is something our solution does.

\section{Document Roadmap}

This document is structured as follows: Chapter \ref{chapter:related-work}
presents and analyses our related work. Chapter \ref{chapter:pulsarcast}
introduces and describes Pulsarcast, its architecture, data structures and
algorithms. Chapter \ref{chapter:implementation} covers the implementation of
our solution, with code snippets and \acrshort{uml} class diagrams. Next,
chapter \ref{chapter:evaluation} explains our evaluation methodology and
presents those results. Finally, chapter \ref{chapter:conclusion} provides a
set of closing remarks and a set of improvements and future work.

